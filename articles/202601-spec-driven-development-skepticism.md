---
title: "仕様駆動開発への懐疑：なぜ2025年にウォーターフォールが復活したのか"
emoji: "🔄"
type: "tech"
topics: ["sdd", "agile", "ai", "開発手法", "ddd"]
published: false
---

:::message
この記事はAIを使用して執筆しています。
:::

## 導入：既視感のある主張

SNSや技術記事で「仕様駆動開発」という言葉を目にするようになった。コーディングエージェントを使った開発において、「仕様をすべて確定してから開発する」「人は仕様を読み変更するだけにし、コーディングエージェントは仕様を読み取ってコードを修正する」「人はコードを触らない」といった主張だ。

この主張を目にした瞬間、私は強い違和感を覚えた。**これは、ウォーターフォールではないか？**

ソフトウェア開発の歴史を振り返れば、ウォーターフォールからアジャイル、エクストリームプログラミング（XP）へと移行してきた経緯がある。実装からのフィードバックの重要性、仕様と実装の相互作用、継続的な改善——これらの知見を無視して、再び「仕様を先にすべて書く」という方向に向かうのは、歴史の逆行に等しいのではないか。

## 仕様駆動開発とは何か

「仕様駆動開発（Specification-Driven Development, SDD）」は、2025年7月にAmazon Web Services（AWS）がリリースした統合開発環境「[Kiro](https://kiro.dev/blog/kiro-and-the-future-of-software-development/)」で提唱された開発手法だ。同年9月にはGitHubが同様の思想に基づく「[GitHub Spec Kit](https://github.blog/news-insights/product-news/introducing-github-spec-kit/)」を公表し、日本でも[KDDI系企業が導入を開始](https://xtech.nikkei.com/atcl/nxt/column/18/00001/11413/)した。

Kiroのワークフローは**要件 → 設計 → 実装**という3段階で構成される。仕様を「真実の源（Source of Truth）」と位置付け、「ドキュメント第一」のアプローチを採用している。人間とAIの共通言語として仕様を扱い、そこからコードを生成させる。

この手法が注目される背景には、「バイブコーディング」への危機感がある。AIに曖昧な指示を出してコードを生成させる手法は、大規模コードベースで混乱を招き、品質とメンテナンス性の懸念を生む。仕様駆動開発は、**「無秩序なAI活用」vs「仕様駆動開発」**という二項対立の構図で語られることが多い。

## 歴史の皮肉：なぜ2025年にウォーターフォールが復活したのか

ソフトウェア開発の歴史を振り返ると、ウォーターフォールモデルは長らく主流だった。要件定義 → 設計 → 実装 → テストという順次的なプロセスは、建築や製造業から借用されたアプローチだ。

しかし、このモデルには致命的な問題があった。**実装段階で初めて発見される問題が多すぎる**のだ。仕様が曖昧だったり、技術的に実現不可能だったり、ユーザーのニーズと乖離していたり——こうした問題は、実際にコードを書いてみないと分からない。

アジャイルやXPが隆盛した理由は、まさにこの点にある。**仕様と実装の間には複雑なフィードバックループがあり、両者を往復しながら改善していく**ことが、良いソフトウェアを作る鍵だと理解されるようになった。

ところが2025年、「要件 → 設計 → 実装」というウォーターフォール的なワークフローが再び登場した。これは歴史の皮肉としか言いようがない。

### なぜ人は「仕様を先に書けば解決する」という幻想に繰り返し陥るのか

この現象の背後には、人間の心理が関係していると私は考えている。

**複雑性への恐怖**——ソフトウェア開発は本質的に複雑だ。その複雑性と向き合うことは、不確実性や混沌に耐えることを意味する。「仕様を先にすべて書く」というアプローチは、この不確実性を排除できるという幻想を与える。

**予測可能性への渇望**——プロジェクト管理者やステークホルダーは、予測可能なプロセスを望む。「仕様が確定すれば、あとは機械的に実装するだけ」という図式は、非常に魅力的に映る。

**極端から極端への振れ**——「バイブコーディング」という無秩序への反動として、「仕様駆動開発」という秩序への逃避が起こる。しかし、適切な複雑性との向き合い方は、往々にして中庸にある。

## Martin Fowlerの懐疑論：権威からの批判

興味深いことに、著名なソフトウェアエンジニアであるMartin Fowlerのブログには、Birgitta Böckelerによる[仕様駆動開発の批判的評価](https://martinfowler.com/articles/exploring-gen-ai/sdd-3-tools.html)が掲載されている。

彼女は実際にKiroとspec-kitを試用し、以下の問題を指摘している：

### 過剰な複雑性

小さなバグ修正に対して、Kiroは4つのユーザーストーリーと16個の受け入れ基準を生成した。彼女はこれを**「釘を打つのにハンマーを使う（sledgehammer to crack a nut）」**と表現している。

つまり、小さなタスクには過剰で、大きなタスクには不十分——適用範囲が極めて狭いということだ。

### 非決定性の問題

さらに致命的なのは、LLM（Large Language Model）の非決定性だ。どれだけ詳細な仕様を書いても、実行のたびにAIが異なるコードを生成する可能性がある。

> "Because of the non-deterministic nature of this technology, there will always remain a very non-negligible probability that it does things that we don't want"

この指摘は本質的だ。**仕様がどれだけ完璧でも、LLMの非決定性により再現性が保証されない**なら、結局のところ実装を見て修正するフィードバックループが不可欠になる。

### 過去の失敗：モデル駆動開発（MDD）

記事では、モデル駆動開発（Model-Driven Development, MDD）という過去の試みにも言及されている。モデル駆動開発もまた「モデル（仕様）から自動的にコードを生成する」というアプローチだったが、広く普及することはなかった。

歴史は繰り返す。

## 抽象化の進化：Next.jsから学ぶ教訓

抽象化は一度で完璧にできるものではない。実装からのフィードバックを受けて、段階的に改善していくものだ。

React開発者であるSebastian Markbåge氏の格言がある：

> 「間違った抽象化から回復するより、抽象化がない状態から回復する方が簡単」

この洞察は、Next.jsのキャッシング戦略の変遷に如実に現れている。

### Next.jsの3段階の進化

**v13-14: 暗黙的なCache（開発者が意識しない抽象化）**

当初、Next.jsは「開発者がキャッシュを意識しなくても、自動的に最適化される」という理想を掲げた。しかし現実には：
- 予想外のデータの鮮度問題
- デバッグの困難さ
- 認知負荷の増大

**v14-15: 段階的な改善（ドキュメント、デフォルト変更）**

コミュニティのフィードバックを受けて、段階的に改善：
- `fetch()`のデフォルトCache廃止
- ドキュメントの透明性向上
- staleTimesオプションの追加

しかし、これらは対症療法に過ぎなかった。

**v16: `"use cache"`による明示的な抽象化**

根本的な設計変更として、`"use cache"`ディレクティブを導入：
```javascript
export async function getData() {
  "use cache";
  return fetch("...").then((res) => res.json());
}
```

**暗黙的（Opt-out）から明示的（Opt-in）への転換**により、開発者が意図した場所でのみキャッシュが働くようになった。

### 教訓：完璧な仕様は事前に書けない

Next.jsチームは当初、「開発者が意識しない」という仕様（設計思想）を掲げた。しかし、実装してみて、実際にユーザーが使ってみて、初めてその仕様の問題が明らかになった。

**抽象的には成立していた設計が、具体化しようとすると矛盾や曖昧さが露呈する**——これは多くの開発者が経験的に知っていることだ。

数年かけてコミュニティのフィードバックを受け、PPR（Partial Pre-Rendering）という新しい発見を経て、ようやく優れた抽象化に到達した。

**もしNext.jsチームが「仕様を先に完璧に確定してから実装する」アプローチを取っていたら、この進化は起こらなかっただろう。**

## 非決定性とスケールの問題を掘り下げる

ここで、私自身も「本当に不可能なのか？」という疑問を持った。何らかの工夫で、仕様駆動開発を機能させることはできないだろうか。

### 全生成 vs 差分マイグレーション

例えば、仕様からすべてのコードを宣言的に生成するのではなく、**仕様の差分に対する既存コードのマイグレーション**として捉えればどうだろうか？既存のコードベースに対して、仕様の変更を反映する形でAIがマイグレーションを行う。

これなら、ある程度は実現可能な気がする。

しかし、すぐに問題が見えてくる。仕様の変更が既存の実装構造と矛盾する場合、どう対処するのか？構造上の致命的な矛盾が入り込むリスクがあり、結局のところ人間による検証が必須になる。

### マイクロサービスレベルなら？

では、スケールを限定すればどうだろう？例えば、EventDrivenアーキテクチャにおける1サービスレベルの粒度——十分に小さく、独立性が高く、境界が明確なコンポーネント。

このサイズなら、仕様駆動が機能するのではないか？

だが、これこそがFowlerの指摘する**「スケールの問題」**だ。小さすぎるタスクには過剰で、大きなタスクには不十分。適用範囲が極めて狭い。

「でも、こうすれば...」と考えたくなる心理——これ自体が、**銀の弾丸を求める欲望**なのかもしれない。複雑性から逃れたいという欲望が、私たちを繰り返し同じ幻想に導く。

## 本質的な問い：何が変わって、何が変わらないのか

コーディングエージェントの登場によって、確かに何かが変わった。しかし、すべてが変わったわけではない。

この問いに答えるため、開発者の認知構造を理解する必要がある。

### 開発者の認知における2つのモデル

開発者の認知は、2つの異なるモデルから構成される：

**コンセプトモデル（あるべき姿）**
- プロダクションに反映していない、フィードバックや外部要因によって生じた「あるべき姿」
- 仮説的な性質を持ち、検証はプロダクションへの反映後にしか得られない
- **仕様駆動開発における「仕様」は、まさにこのコンセプトモデルを指している**

**プロダクションモデル（現状の理解）**
- 現在稼働中のプロダクトを反映した「現状の理解」
- コードベースや稼働プロダクトとの相互作用を通じて、比較的即座にフィードバックが得られる

**開発とは、本質的に「コンセプトモデルをプロダクションモデルに収束させる」ことである。**

### 抽象と具体のフィードバックループ

コードを書く行為は、**「抽象的なモデルを具体化する」**過程だ。この具体化の過程で、モデルへのフィードバックが発生する。

**抽象的には成立していたはずの設計が、具体化しようとすると矛盾や曖昧さが露呈する**——これは多くの開発者が経験的に知っている。

逆に、コードを読む行為は**「具体から抽象を再構築する」**過程であり、コードベースからプロダクションモデルを復元する。ビルドエラーやテスト結果も、具体からのフィードバックとしてこのループに含まれる。

### 仕様駆動開発を認知構造で再解釈する

仕様駆動開発は、**コンセプトモデルを先に完璧に構築してから、一気にプロダクションモデルに反映する**アプローチだ。

しかし、これには致命的な問題がある：

1. **フィードバックが得られない** - コンセプトモデルの検証ができない
2. **差分が蓄積し続ける** - コンセプトモデルとプロダクションモデルの乖離が拡大
3. **不確実性が最大化される** - 実装段階で初めて問題が発覚

これは、ウォーターフォールがなぜ失敗したかの本質的な理由でもある。**差分負荷と不確実性を最大化するプロセス**なのだ。

### 変わったこと

**仕様→実装の変換コストが劇的に低下した。**

以前なら数時間かかっていた実装が、数分で完了する。つまり、**コンセプトモデルをプロダクションモデルに反映するサイクルが爆速になった**。

プロトタイピングが高速化し、試行錯誤のサイクルが短縮された。

### 変わらないこと

しかし、以下は変わっていない：

- **良い仕様（コンセプトモデル）を書く難しさ** — 曖昧さのない、実装可能なモデルを構築することは、依然として難しい
- **実装から得られるフィードバックの価値** — 実際に動くコード（プロダクションモデル）を見ることで初めて分かる問題は多い
- **ドメインモデルの構築の難しさ** — 複雑なドメインを適切にモデル化することは、コードを書く以前の問題だ
- **LLMの非決定性という新しい制約** — むしろ新たな不確実性が加わった
- **コンセプトモデルとプロダクションモデルの間に差分が存在し続ける**という構造的な問題

### 本質：コンセプトとプロダクションの高速往復

コーディングエージェントの本質は、**「コンセプトモデルを先に確定する」ことではなく、「コンセプトモデルとプロダクションモデルを高速に往復できる」ことにある**と私は考えている。

以前は、仕様（コンセプトモデル）を変更してから実装（プロダクションモデル）を更新するまでに時間がかかった。だから「仕様を先に確定する」ことが重視された。

しかし今は、両者を何度でも高速に往復できる。だからこそ、**フィードバックループを回しながら両者を共進化させる**アプローチが可能になった。

**差分をゼロにすることは原理的に不可能だ**（常に外部から新たなフィードバックが入り、コンセプトモデルが先に進んでしまう）。重要なのは、**差分を小さく保ち、扱いやすくする**ことなのだ。

## DDDとコンテキストの制約：認知構造の観点から

ドメイン駆動設計（Domain-Driven Design, DDD）の観点からも、仕様駆動開発には疑問がある。

Eric Evansが『Domain-Driven Design』で強調したのは、**コードとモデルの深い結びつき**だ。「ユビキタス言語」は、ドメインエキスパート、開発者、そしてコードの間で共有される。これは**仕様とコードが分離していない**ことを意味する。

認知構造の観点から言えば、ユビキタス言語は**コンセプトモデルとプロダクションモデルの翻訳負荷を下げる**試みだ。同じ言葉で「あるべき姿」と「現状の理解」を語ることで、両者の乖離を最小化する。

### コードこそが真実：認知負荷の観点

**コードベースと文書の両方をメンテナンス対象とすると、「コードベースと文書の差分」という新たな認知負荷の源泉が生じる。**

開発者は、どちらが正しいのかを判断するコストを払わなければならない。この観点から、**正の情報源（Source of Truth）はコードベースに限定すべき**だ。

仕様駆動開発が「仕様を真実の源」とすることの問題は、まさにここにある：
- コンセプトモデル（仕様）とプロダクションモデル（コード）の両方をメンテナンス
- 両者の差分が認知負荷を増大させる
- どちらが正しいかの判断コストが発生

むしろ、**コードベースをプロダクションモデルの正の情報源とし、ドキュメントは補助的存在**として位置付けるべきだ。

### AIとドメインモデルの共有

コーディングエージェントとの対話においても、ドメインモデルの共有が必要だ。しかし、現実には**コンテキストサイズの制約**という新しい問題がある。

LLMには入力できるトークン数に上限がある。仕様書とコードの両方をAIに読ませるのは、コンテキストを浪費する。

コードベースに十分な構造と意図が表現されていれば、AIはコードベースを読むことでプロダクションモデルを理解できる。ドキュメントは、コードベースが表すものを理解する補助として機能する。

少なくとも、コードレベルや技術レイヤーの理解がなければ、コーディングエージェントとドメインモデルを共有することは難しい。仕様書だけでは、実装の具体的な構造・状態遷移・振る舞いを伝えきれない。

### コンセプトモデル検討段階の文書

コンセプトモデル検討段階で作成される文書（設計案、提案書、ADRなど）については、プロダクションモデルへのマージ（実装・デプロイ）段階で役割を終えるものとして扱うのが妥当だろう。

これらは「検討の記録」として残す価値はあるが、**継続的なメンテナンス対象とはしない**前提を明確にしておくことで、差分負荷の増大を防げる。

## 第三の道：仕様・実装共進化のアプローチ

「バイブコーディング」でも「仕様駆動開発」でもない、第三の道があると私は考えている。それは**仕様と実装を高速に往復する**アプローチだ。

認知構造の観点から言えば、**コンセプトモデルとプロダクションモデルを小さな差分で保ちながら、フィードバックループを回し続ける**ことだ。

### 具体例：認証機能の実装

例えば、Webアプリケーションに認証機能を追加するとしよう。

**従来のウォーターフォール的アプローチ：**
1. 認証のコンセプトモデルをすべて確定（OAuth 2.0、JWT、リフレッシュトークン、セッション管理...）
2. 詳細な設計書を作成
3. 実装
4. 実装段階で「セッションの有効期限をどこで管理する？」「トークンの保存先は？」といった問題が噴出
5. コンセプトモデルに戻って修正
6. 再実装

この間、コンセプトモデルとプロダクションモデルの差分は拡大し続け、認知負荷が増大する。

**仕様・実装共進化のアプローチ：**
1. 最小限のコンセプトモデルを構築（「ユーザーはメールアドレスとパスワードでログインできる」）
2. コーディングエージェントに実装させる（プロダクションモデルに反映）
3. 生成されたコードを見て、「あ、トークンの保存はlocalStorageか。でもXSS対策でhttpOnlyクッキーにすべきでは？」と気づく（プロダクションモデルからコンセプトモデルへのフィードバック）
4. コンセプトモデルを更新し、再実装
5. 「リフレッシュトークンはどうする？」という新たな疑問が浮かぶ
6. コンセプトモデルに追加、実装、検証...

このサイクルを高速に回すことで、両者の差分を小さく保ちながら、段階的に洗練させていく。

**プロダクションモデル（実装）からのフィードバックがなければ、良いコンセプトモデル（仕様）は書けない。**

### 実践的なワークフロー

私が考える実践的なワークフローは以下のようなものだ：

1. **最小限のコンセプトモデルから始める** — 完璧を目指さない
2. **コードを生成させる** — AIに実装させ、プロダクションモデルに反映
3. **実装を読み、理解する** — コードベースからプロダクションモデルを構築
4. **問題や改善点を発見する** — プロダクションモデルからコンセプトモデルへのフィードバック
5. **コンセプトモデルを更新する** — 学びを反映
6. **再実装** — 改善されたプロダクションモデルを生成

このサイクルを繰り返すことで、コンセプトモデルとプロダクションモデルが共進化する。コンセプトモデルは実装の経験から洗練され、プロダクションモデルはコンセプトモデルの意図を正確に反映する。

重要なのは、**差分を小さく保つ**ことだ。大きなコンセプトモデルを一気に構築するのではなく、小さな単位でプロダクションモデルに反映し、フィードバックを得てから次を構築する。

## 結論：複雑性との向き合い方

仕様駆動開発の主張者たちが見落としているのは、**ソフトウェア開発の本質的な複雑性**だと私は考えている。

### 開発の本質的構造

本稿で見てきたように、開発とは本質的に「コンセプトモデルをプロダクションモデルに収束させる」ことだ。

しかし、この収束は原理的に完了しない。常に外部から新たなフィードバックが入り、コンセプトモデルが先に進んでしまうからだ。ユーザーからの要望、環境の変化、技術の進化——これらは私たちの都合を待ってくれない。

複雑性は、仕様（コンセプトモデル）を詳細化することで消えるものではない。むしろ、**仕様と実装の相互作用の中にこそ存在する**。

実装してみて初めて分かる問題、コードを書いてみて初めて見える設計の矛盾——これらは、どれだけ仕様を書いても事前に完全に予測することはできない。Next.jsチームが数年かけて学んだように、**抽象的には成立していた設計が、具体化しようとすると矛盾や曖昧さが露呈する**のだ。

### 差分をゼロにするのではなく、扱いやすく保つ

この「永遠に追いかけ続ける構造」を前提としたとき、認知負荷を最小化する戦略は**「差分をゼロにする」ことではなく「差分を扱いやすく保つ」**ことになる。

仕様駆動開発は、差分をゼロにしようとする試みだ。しかし、それは不可能であり、むしろ差分を蓄積させ、認知負荷を最大化する。

**銀の弾丸はない。** これは、Fred Brooksが1986年に指摘したことだが、2025年の今でも変わらない真理だ。

### 中庸の探求

コーディングエージェントという強力なツールを手に入れた私たちは、「これで仕様を書けば自動的にコードができる」という幻想に飛びつきたくなる。

しかし、歴史が教えてくれるのは、**極端から極端への振れは失敗する**ということだ。

適切な複雑性との向き合い方は、中庸にある。バイブコーディングの無秩序でも、仕様駆動開発の硬直でもなく、**コンセプトモデルとプロダクションモデルを小さな差分で保ちながら、フィードバックループを回し続ける**こと。

これが、仕様・実装共進化の本質だ。

### エージェント時代でも変わらない本質

Next.jsのキャッシング戦略の進化、ウォーターフォールからアジャイルへの移行、そして今回の仕様駆動開発論争——これらすべてに共通するのは、**フィードバックループの重要性**だ。

実装からのフィードバックを受けて仕様を改善し、仕様の意図を実装に反映し、またフィードバックを受ける。この循環こそが、良いソフトウェアを生み出す鍵である。

エージェント時代でも変わらない本質——それは、**フィードバックループ**だ。

---

## 参考文献

- [Understanding Spec-Driven-Development: Kiro, spec-kit, and Tessl - Martin Fowler](https://martinfowler.com/articles/exploring-gen-ai/sdd-3-tools.html)
- [Kiro and the future of AI spec-driven software development](https://kiro.dev/blog/kiro-and-the-future-of-software-development/)
- [仕様駆動開発（Spec-driven development）とは？](https://atmarkit.itmedia.co.jp/ait/articles/2510/07/news022.html)
- [KDDI系が仕様駆動開発を採用、AIで業務は「設計8割・開発2割」に](https://xtech.nikkei.com/atcl/nxt/column/18/00001/11413/)
- [コーディング変革！「仕様駆動開発（SDD）」の手引き](https://forest.watch.impress.co.jp/docs/serial/aidev/2071380.html)
